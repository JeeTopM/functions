"""
Функция zip_longest()
Как уже известно, функция zip() объединяет элементы различных последовательностей.
Особенностью функции является то, что при передаче последовательностей различной длины
    элементы последовательности большей длины будут отброшены.
Реализуйте функцию zip_longest(), которая принимает переменное количество позиционных аргументов,
    каждый из которых является списком, и один необязательный именованный аргумент fill, имеющий значение по умолчанию None.
Функция должна объединять элементы переданных последовательностей в кортежи, аналогично функции zip(),
    и возвращать в виде списка, но если последовательности имеют различную длину,
    недостающие элементы последовательностей меньшей длины должны принимать значение fill.
"""


def zip_longest():
    pass


print(zip_longest([1, 2, 3, 4, 5], ['a', 'b', 'c'], fill='_'))
# [(1, 'a'), (2, 'b'), (3, 'c'), (4, '_'), (5, '_')]

data = [[1, 2, 3, 4, 5], ['one', 'two', 'three'], ['I', 'II']]
print(zip_longest(*data))
# [(1, 'one', 'I'), (2, 'two', 'II'), (3, 'three', None), (4, None, None), (5, None, None)]

data = [[1, 2, 3, 4, 5], ['one', 'two', 'three', 'four', 'five'], ['I', 'II', 'III', 'IV', 'V']]
print(zip_longest(*data))
# [(1, 'one', 'I'), (2, 'two', 'II'), (3, 'three', 'III'), (4, 'four', 'IV'), (5, 'five', 'V')]